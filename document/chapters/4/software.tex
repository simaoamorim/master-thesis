\section{Software development} \label{sec:software-devel}
As we have explained previously, the slave device we are developing on this project needs some custom functionality that needs to be programmed.
The following sections will present and explain the algorithms and techniques used during development of each software component that compose the final control program.

The presentation of the several segments will mostly follow the order by which they were developed in order to better explain the programming logic and challenges we had to overcome during the process.

% Slave node software
% `- DFR0592 driver
\subsection{DFR0592 driver}
The first software module we started to develop was the 'driver` library that interacts with the DC motor control board, the DFRobot's DFR0592.
The communication with the DFR0592 is done via the I\textsuperscript{2}C channel and is based on registers.
If we want to read a value on register X, we simply send the register address we want to read and the board responds with the corresponding value.
If, instead, we wish to write a value, we also send the register address but with the most significant bit of the transmitted byte set to 1, which indicates a write operation (as opposed to a read operation, when it is 0), followed by the value we want to be written.

We began by testing the device functionality with a Python \cite{sw:python} script provided by the manufacturer.
We used it mostly to get a sense of what parameters and variables were needed to set the motor speed and get the velocity feedback value, but also to get acquainted to how the I2C communication transactions worked.

It was at this stage that we found out the velocity calculation algorithm implemented on the board was too slow to be used in a control loop because it only updated the feedback value once every 100ms.
This is what lead us to decide and change the encoder connection to the Raspberry Pi's GPIO pins and create our own encoder 'driver` and velocity/position calculation algorithm.
This way we will have more flexibility on the feedback calculation algorithm, being able to run it with virtually any period.

After making sure our prototype communication algorithm was working correctly in Python, we began to 'translate` it to the C programming language.
Naturally some modification had to be made, especially because C is an event-oriented language, as opposed to Python which is mainly object-oriented.
We overcame this by creating a C struct with the same object data that we used in the Python prototype, paired with helper functions that perform the same operations as the Python's object methods.
The developed C functions all take, at least, one argument: a pointer to a variable of type \verb|struct dfr_board|, which is a pseudo-object representing a DFR0592 board.
The following \autoref{lst:dfr_struct} is an excerpt of the header file containing the definition of said struct.

\lstinputlisting[language=C,firstline=23,lastline=31,caption=Example code,label=lst:dfr_struct]{../src/DFR0592/dfr0592.h}

Each DFR0592 board comes pre-configured with the I\textsuperscript{2}C address \verb|0x10| but they can be changed, meaning several of these boards can be used simultaneously.
As such, the library was designed in a way that, in future works, one can communicate with several boards simultaneously

The mentioned approach was used in order to mimic the working principle of an object-oriented programming language in C.
This was mostly useful on the libraries that may need to manage several pseudo-objects of the same type (e.g. the PID algorithm library), but we used the same principle throughout all code-base, for consistency reasons.

% `- GPIO encoder 'driver'
\subsection{Raspberry Pi's GPIO encoder driver}
After having determined the best approach for velocity and position measurement was to connect the motor encoder to the GPIO of the Raspberry Pi, it prompted us to develop a dedicated driver to handle the input signals.
The designed driver converts the logical values from the quadrature encoder signals A and B into a step sequence by mapping the A/B pair of values onto a sequence number, as shown in \autoref{table:encoder-ab-sequence}.

\begin{table}[htp]
	\centering
	\caption{Encoder step sequence mapping}
	\label{table:encoder-ab-sequence}
	\begin{tabular}{|c|c|c|}
		\hline
		A & B & sequence  \\
		\hline
		0 & 0 & 0         \\
		\hline
		1 & 0 & 1         \\
		\hline
		1 & 1 & 2         \\
		\hline
		0 & 1 & 3         \\
		\hline
	\end{tabular}
\end{table}

To gain software access to the GPIO lines on the Raspberry Pi, the Linux C library \verb|libgpiod| \cite{lib:libgpiod} was used.
This library allows two modes of acquiring input values: periodic polling and event-triggered action.
Our implementation uses periodic polling, in which the new update of values will be triggered by the main control task, following its cyclic period.
The event-triggered action will call a specified function whenever the configured input(s) line changes its value, either from boolean 0 to 1 or 1 to 0.

The periodic polling approach was easy to prototype and implement but it will have less precision when working with slow speeds, meaning an implementation based on event-triggered actions could be implemented as future work, in order to improve both performance and measurement precision in slow speeds.
As we were mostly interested in creating a proof-of-concept system, we accepted the reduced precision on slower speeds, in exchange for the simplest and smallest implementation.

After the encoder signals are mapped to the sequence number, a counter variable is updated after every polling iteration, according to the difference between the current and previous sequence numbers.
If the sequence number increases or jumps from 3 to 0, the counter is incremented accordingly, and vice versa.
This counter value will later be used in the velocity and position calculation library, where every iteration its value is compared to the previous one and, combined with the necessary ratios from the encoder's Pulses per Revolution (PPR) and the motor gearbox ratio, the average velocity and angular positions can be estimated for the current time-step.

Again, for consistency reasons, this software library was designed to mimic the object-oriented programming style and thus it's possible to connect several encoders 

% `- velocity/position calculation algorithm
\subsection{Velocity and position calculation algorithm}
Even though this algorithm was implemented as a separate library from the encoder driver, it heavily relies on data from said driver.
Having it implemented as a separate module means a different algorithm can be developed and be used as a swap-in replacement for the current one.

The current implementation works as a standalone cyclic task that performs the following actions:
\begin{enumerate}
	\item fetches the above mentioned encoder counter variable from the encoder driver;
	\item fetches the current internal clock timestamp and calculates the time delta from the last iteration; \label{misc:pvstep2}
	\item calls the internal \verb|_calc_position()| function, that applies the configured encoder scale, gearbox ratio and transforms the value into degrees;
	\item calls the internal \verb|_calc_velocity()| function, that applies the same scales but also uses the time delta calculated in step \ref{misc:pvstep2} to convert the value to a velocity, in Revolutions per Minute (RPM);
	\item saves the current timestamp as the previous one, to be used on the next iteration;
\end{enumerate}

Following the same design pattern of the previous modules, a C struct variable is used to store the pseudo-object data, including the calculated velocity and position values.
A such, a more complex system that may need to calculate velocities and position for multiple motors simultaneously can be implemented with this library, due to the mimicking of an object-oriented implementation.

Even though the data struct is transparent to outside of the library, public functions are provided to fetch these values.
These functions include an interlock variable to control the access to the memory regions where such values are stored (the 'pthread mutex` implementation is used), to make sure the cyclic calculation task is not disrupted by any external fetch operations.
This is common technique used in multi-threaded software where concurrent running parts of the same software application need to access the same memory location, but naturally they cannot do it simultaneously.

% `- PID algorithm
% `- netHAT handler
% `- miscelaneous glue code
