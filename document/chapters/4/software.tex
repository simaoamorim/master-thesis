\section{Software development} \label{sec:software-devel}
As we have explained previously, the slave device we are developing on this project needs some custom functionality that needs to be programmed.
The following sections will present and explain the algorithms and techniques used during development of each software component that compose the final control program.

The presentation of the several segments will mostly follow the order by which they were developed in order to better explain the programming logic and challenges we had to overcome during the process.

% Slave node software
% `- DFR0592 driver
\subsection{DFR0592 driver}
The first software module we started to develop was the 'driver` library that interacts with the DC motor control board, the DFRobot's DFR0592.
The communication with the DFR0592 is done via the I\textsuperscript{2}C channel and is based on registers.
If we want to read a value on register X, we simply send the register address we want to read and the board responds with the corresponding value.
If, instead, we wish to write a value, we also send the register address but with the most significant bit of the transmitted byte set to 1, which indicates a write operation (as opposed to a read operation, when it is 0), followed by the value we want to be written.

We began by testing the device functionality with a Python \cite{programming:python} script provided by the manufacturer.
We used it mostly to get a sense of what parameters and variables were needed to set the motor speed and get the velocity feedback value, but also to get acquainted to how the I2C communication transactions worked.

It was at this stage that we found out the velocity calculation algorithm implemented on the board was too slow to be used in a control loop because it only updated the feedback value once every 100ms.
This is what lead us to decide and change the encoder connection to the Raspberry Pi's GPIO pins and create our own encoder 'driver` and velocity/position calculation algorithm.
This way we will have more flexibility on the feedback calculation algorithm, being able to run it with virtually any period.

% `- GPIO encoder 'driver'
% `- PID algorithm
% `- velocity/position calculation algorithm
% `- netHAT handler
% `- miscelaneous glue code
