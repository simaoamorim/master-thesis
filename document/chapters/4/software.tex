\section{Software development} \label{sec:software-devel}
As we have explained previously, the slave device we are developing on this project needs some custom functionality that needs to be programmed.
The following sections will present and explain the algorithms and techniques used during development of each software component that compose the final control program.

The presentation of the several segments will mostly follow the order by which they were developed in order to better explain the programming logic and challenges we had to overcome during the process.

% Slave node software
% `- DFR0592 driver
\subsection{DFR0592 driver}
The first software module we started to develop was the 'driver` library that interacts with the DC motor control board, the DFRobot's DFR0592.
The communication with the DFR0592 is done via the I\textsuperscript{2}C channel and is based on registers.
If we want to read a value on register X, we simply send the register address we want to read and the board responds with the corresponding value.
If, instead, we wish to write a value, we also send the register address but with the most significant bit of the transmitted byte set to 1, which indicates a write operation (as opposed to a read operation, when it is 0), followed by the value we want to be written.

We began by testing the device functionality with a Python \cite{programming:python} script provided by the manufacturer.
We used it mostly to get a sense of what parameters and variables were needed to set the motor speed and get the velocity feedback value, but also to get acquainted to how the I2C communication transactions worked.

It was at this stage that we found out the velocity calculation algorithm implemented on the board was too slow to be used in a control loop because it only updated the feedback value once every 100ms.
This is what lead us to decide and change the encoder connection to the Raspberry Pi's GPIO pins and create our own encoder 'driver` and velocity/position calculation algorithm.
This way we will have more flexibility on the feedback calculation algorithm, being able to run it with virtually any period.

After making sure our prototype communication algorithm was working correctly in Python, we began to 'translate` it to the C programming language.
Naturally some modification had to be made, especially because C is an event-oriented language, as opposed to Python which is mainly object-oriented.
We overcame this by creating a C struct with the same object data that we used in the Python prototype, paired with helper functions that perform the same operations as the Python's object methods.
The developed C functions all take, at least, one argument: a pointer to a variable of type \verb|struct dfr_board|, which is a pseudo-object representing a DFR0592 board.
The following \autoref{lst:dfr_struct} is an excerpt of the header file containing the definition of said struct.

\lstinputlisting[language=C,firstline=23,lastline=31,caption=Example code,label=lst:dfr_struct]{../src/DFR0592/dfr0592.h}

Each DFR0592 board comes pre-configured with the I\textsuperscript{2}C address \verb|0x10| but they can be changed, meaning several of these boards can be used simultaneously.
As such, the library was designed in a way that, in future works, one can communicate with several boards simultaneously

The mentioned approach was used in order to mimic the working principle of an object-oriented programming language in C.
This was mostly useful on the libraries that may need to manage several pseudo-objects of the same type (e.g. the PID algorithm library), but we used the same principle throughout all code-base, for consistency reasons.

% `- GPIO encoder 'driver'
\subsection{Raspberry Pi's GPIO encoder driver}
After having determined the best approach for velocity and position measurement was to connect the motor encoder to the GPIO of the Raspberry Pi, it prompted us to develop a dedicated driver to handle the input signals.
The designed driver converts the logical values from the quadrature encoder signals A and B into a step sequence by mapping the A/B pair of values onto a sequence number, as shown in \autoref{table:encoder-ab-sequence}.

\begin{table}[htp]
	\centering
	\caption{Encoder step sequence mapping}
	\label{table:encoder-ab-sequence}
	\begin{tabular}{|c|c|c|}
		\hline
		A & B & sequence  \\
		\hline
		0 & 0 & 0         \\
		\hline
		1 & 0 & 1         \\
		\hline
		1 & 1 & 2         \\
		\hline
		0 & 1 & 3         \\
		\hline
	\end{tabular}
\end{table}

% `- velocity/position calculation algorithm
% `- PID algorithm
% `- netHAT handler
% `- miscelaneous glue code
